
/*
 * zipfian_test.cpp - Tests zipfian generator
 *
 * The Zipfian generator are adapted from:
 *   https://github.com/efficient/msls-eval/blob/master/zipf.h
 *   https://github.com/efficient/msls-eval/blob/master/util.h
 */

#include "../src/test_suite.h"
#include <unistd.h>

/*
 * TestZipfianTheta() - Tests zipfian dist with a given theta
 */
void TestZipfianTheta(double theta) {
  _PrintTestName();
  dbg_printf("Theta = %f\n", theta);
  
  // Set theta = 0 and this yields uniform distribution from 0 and wraps
  // back at n
  Zipfian zipf{30 * 1024 * 1024, theta, 0};
  
  for(int i = 0;i < 200;i++) {
    dbg_printf("i = %d; zipfian = %lu\n", i, zipf.Get()); 
  }
  
  return;
}

/*
 * DrawZipfianDistribution() - Draw a diagram on the distribution
 *
 * This function generates a workload first, and then output a distribution file
 * and draws a diagram using gnuplot
 */
void DrawZipfianDistribution(double theta, 
                             size_t data_size,
                             size_t range, 
                             size_t interval_size) {
  // This is the name of the output file
  static constexpr const char *data_file_name = "_zipfian_dist.txt";
  static constexpr const char *cmd_file_name = "_zipfian_command.txt";
  
  // This is the command we use to draw the bar chart
  static constexpr char command[] = \
    "set term png\n"
    "set output \"zipfian_dist.png\"\n"
    "set boxwidth 0.5\n"
    "set style fill solid\n"
    "plot \"_zipfian_dist.txt\" using 1:2 with boxes\n";
                                                                                        
  _PrintTestName();
  
  // Since we will do integer division, to avoid peculiar problems
  // assert() these three first
  assert(data_size != 0UL);
  assert(range != 0UL);
  assert(interval_size != 0UL);
  
  // We use this vector to hold data for later processing
  std::vector<uint64_t> data;
  
  // We use random number generated by the current time
  Zipfian zipf{range, theta, static_cast<uint64_t>(time(nullptr))};
  zipf.Fill(&data, data_size);
  
  // This might be not sufficient because the last interval may not be
  // complete and integer division will ignore it
  size_t interval_count = range / interval_size;
  if((range % interval_size) != 0) {
    interval_count++; 
  }
  
  // Use this to store the number of points in each interval
  // Initialize all counters to 0
  std::vector<uint64_t> counter_list{};
  counter_list.resize(interval_count, 0UL);
  
  // Loop for each data point in the ..
  for(uint64_t num : data) {
    uint64_t index = num / interval_size;
    // Increament the counter in the interval
    counter_list.at(index)++;
  }
  
  FILE *fp = fopen(data_file_name, "w");
  assert(fp != nullptr);
  
  dbg_printf("Writing distribution file %s...\n", data_file_name);
  
  uint64_t i = 0UL;
  uint64_t total = 0UL;
  // Then loop over all counters to print them out
  // The format is:
  // [index of bar] [bar title] [actual number]
  for(uint64_t counter : counter_list) {
    fprintf(fp, 
            "%lu %lu\n", 
            i, 
            counter);
            
    total += counter;
    i++;
  }
  
  // Total number of points must be also the data size
  assert(total == data_size);
  
  int ret = fclose(fp);
  assert(ret == 0);
  
  ///////////////////////////////
  // Then open the command file
  ///////////////////////////////
  
  fp = fopen(cmd_file_name, "w");
  assert(fp != nullptr);
  
  dbg_printf("Writing command file %s...\n", cmd_file_name);
  ret = fwrite(command, 1, sizeof(command), fp);
  assert(ret == sizeof(command));
  
  ret = fclose(fp);
  assert(ret == 0);
  
  char shell_command[256];
  sprintf(shell_command, "gnuplot %s", cmd_file_name);
  
  // Finally execute command
  dbg_printf("Executing command: %s\n", shell_command);
  system(shell_command);
  
  // Remove temporary files
  ret = unlink(cmd_file_name);
  assert(ret == 0);
  ret = unlink(data_file_name);
  assert(ret == 0);
  
  return;
}

int main() {
  TestZipfianTheta(0.0);
  TestZipfianTheta(50.0);
  TestZipfianTheta(0.99);
  
  // 10 M data points within 50 M range
  // each interval is 50K in the bar chart
  // So there are 1K bars in the chart
  DrawZipfianDistribution(0.99, 
                          10 * 1024 * 1024, 
                          50 * 1024 * 1024, 
                          50 * 1024);
  
  return 0; 
}
